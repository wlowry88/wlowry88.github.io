<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: language | The Eternal Whitebelt]]></title>
  <link href="http://wlowry88.github.io/blog/categories/language/atom.xml" rel="self"/>
  <link href="http://wlowry88.github.io/"/>
  <updated>2014-11-29T16:20:43-08:00</updated>
  <id>http://wlowry88.github.io/</id>
  <author>
    <name><![CDATA[Will Lowry]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Public and Private Methods in Ruby]]></title>
    <link href="http://wlowry88.github.io/blog/2014/09/08/public/"/>
    <updated>2014-09-08T17:33:02-07:00</updated>
    <id>http://wlowry88.github.io/blog/2014/09/08/public</id>
    <content type="html"><![CDATA[<h3>Method Access Rules</h3>

<p>While the end user of your program is never going to be using the methods you define in a class directly, it is still helpful to control access to your methods. Envision a team situation in which multiple developers use instances of the same class; it is useful to control which methods can be used.</p>

<p>A simple way to think about the difference is to imagine our class is an airplane (I&rsquo;m writing this aboard one, in fact.)</p>

<!-- More -->


<h3>Public Methods</h3>

<p>In our <code>Plane</code> class, we have a few public instance methods. We don&rsquo;t need to specify that a method be public because that is their default.</p>

<p>```ruby
class Plane</p>

<pre><code>attr_reader :type, :fuel, :landed, :people, :personal_info_of_passengers, :burning_fuel

def initialize(model)
    @model = model
    @fuel = 100
    @airborne = false
    @burning_fuel = false
end

def take_off
    puts "Firing up engines"
    puts "Fuel levels are #{fuel}."
    @airborne = true
    fire_up_engine
end

def fire_up_engine
    puts "firing up the engine"
    begin_gas_combustion
end

def begin_gas_combustion
    puts "combustin' the gas!"
    burning_fuel = true
end

def personal_info_of_passengers(people)
    people.map do |person|
        person.social_security_number
    end
end
</code></pre>

<p>end
```
Woah, wait a second. It&rsquo;s all well and good that we&rsquo;re able to see what type of plane we&rsquo;re working with, the fuel levels, and even whether or not we&rsquo;re airborne. However, there are a few things that we definitely don&rsquo;t want to be usable outside our class.</p>

<p>An object is easy to think about as something that does tasks for you, and its methods are the actions of doing those things. Public methods are like the API &ndash; where calls are made to the instances of the object. Private methods, on the other hand, are tasks that you might not want to be used freely. For example, the method <code>begin_gas_combustion</code> is a component of the method <code>fire_up_engine</code> but it&rsquo;s unclear whether or not you&rsquo;d want to use it in any other context. In fact, it would probably be unsafe to be able to use it in other contexts. Luckily, Ruby enables use of private methods to get around this problem.</p>

<h3>Private Methods</h3>

<p><strong>A private method cannot be called with an explicit receiver.</strong> This means that if we specify <code>begin_gas_combustion</code> to be a private method, we shouldn&rsquo;t be able to call <code>begin_gas_combustion</code> on instances of our <code>Plane</code> class explicitly. Let&rsquo;s rewrite a bit of our Plane class:</p>

<p>```ruby
class Plane</p>

<p>&hellip;</p>

<pre><code>def fire_up_engine
    puts "firing up the engine"
    begin_gas_combustion
end

private

    def begin_gas_combustion
        "combustin' da gas!"
        burning_fuel = true
    end
</code></pre>

<p>end
<code>
Ok, that seems to make a bit more sense. Let's test out our methods.
If you try, you'll get the following:
</code>ruby</p>

<p>wills_plane = Plane.new(747)
wills_plane.begin_gas_combustion</p>

<h1>=> &lsquo;<main>&rsquo;: private method &lsquo;begin_gas_combustion&rsquo; called for #&lt;Plane:0x00000002aeae50> (NoMethodError)`</h1>

<p><code>``
This makes sense based on our definition of private methods - the instance</code>will` is now the explicit receiver of the method as called. However, when we try the following:</p>

<p>```ruby</p>

<p>wills_plane.fire_up_engine</p>

<h1>=> &ldquo;firing up the engine&rdquo;</h1>

<h1>=> &ldquo;combustin' da gas!&rdquo;</h1>

<p>```
Here, since the method gets called within a public method, there is an implicit receiver &ndash; the specific instance of the object &ndash; and we are ok.</p>

<h3>Private Setter (=) Methods</h3>

<p>Private methods with the &ldquo;no explicit receiver&rdquo; rule do hit problems, however, with writer / setter methods. In these methods, you can&rsquo;t use the implicit receiver because Ruby would assume you were using a local variable instead of a method without the keyword <code>self</code>. Therefore, there is an exception &ndash; Ruby doesn&rsquo;t apply the rule to setter methods as long as the explicit receiver is <code>self</code>.</p>

<h3>You Can Bypass Private Methods with &lsquo;send&rsquo;</h3>

<p>Ruby has given us a way to get around our rule, however. You can always just use the <code>send</code> method to send any method to any object.</p>

<p>Hopefully this clears up the value / usage of private methods, and see you next time.</p>
]]></content>
  </entry>
  
</feed>
