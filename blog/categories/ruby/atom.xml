<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ruby | The Eternal Whitebelt]]></title>
  <link href="http://wlowry88.github.io/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://wlowry88.github.io/"/>
  <updated>2014-09-23T12:28:13-04:00</updated>
  <id>http://wlowry88.github.io/</id>
  <author>
    <name><![CDATA[Will Lowry]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Python from Ruby]]></title>
    <link href="http://wlowry88.github.io/blog/2014/09/16/python-from-ruby/"/>
    <updated>2014-09-16T16:34:09-04:00</updated>
    <id>http://wlowry88.github.io/blog/2014/09/16/python-from-ruby</id>
    <content type="html"><![CDATA[<p>Recently, I&rsquo;ve been learning a lot more about Python. I&rsquo;m a Rubyist by background but I&rsquo;m interested in learning Python because of all it&rsquo;s amazing libraries, especially those related to data science. This post is about a few differences that are useful to think about coming from a Ruby background. This is also largely a reaction to material I&rsquo;ve gathered from the web, including <a href="http://stackoverflow.com/questions/4769004/learning-python-from-ruby-differences-and-similarities">this</a> thread on Stack Overflow.</p>

<!--More-->


<h3>A Few Differences So Far</h3>

<p><strong>Philosophy</strong>. It seems that Python and Ruby were conceived with slightly different aims. While both are high-level, interpreted, general programming languages, Python is very focused on being explicit. I only just learned about this easter egg in Python:</p>

<p>```python</p>

<blockquote><blockquote><blockquote><p>import this</p></blockquote></blockquote></blockquote>

<p>&ldquo;&rdquo;&ldquo;The Zen of Python, by Tim Peters</p>

<p>Beautiful is better than ugly.
Explicit is better than implicit.
Simple is better than complex.
Complex is better than complicated.
Flat is better than nested.
Sparse is better than dense.
Readability counts.
Special cases aren&rsquo;t special enough to break the rules.
Although practicality beats purity.
Errors should never pass silently.
Unless explicitly silenced.
In the face of ambiguity, refuse the temptation to guess.
There should be one&mdash; and preferably only one &mdash;obvious way to do it.
Although that way may not be obvious at first unless you&rsquo;re Dutch.
Now is better than never.
Although never is often better than <em>right</em> now.
If the implementation is hard to explain, it&rsquo;s a bad idea.
If the implementation is easy to explain, it may be a good idea.
Namespaces are one honking great idea &mdash; let&rsquo;s do more of those!&ldquo;&rdquo;&ldquo;
```
When I was learning Ruby, I remember being blown away by the number of ways to solve any given problem. Yukihiro Matsumoto, the creator of Ruby once said, "I hope to see Ruby help every programmer in the world to be productive, and to enjoy programming, and to be happy. That is the primary purpose of Ruby language.&rdquo; I don&rsquo;t know about you, but it seems pretty clear that Ruby is intended to be programmer-centric. If there are two Rubyists who choose to solve a problem two different ways, let them! This stands in sharp contrast to several items from the Python &ldquo;creed&rdquo; &ndash; especially &ldquo;There should be one&mdash; and preferably only one &mdash;obvious way to do it.&rdquo; Python is not programmer-centric, it&rsquo;s program-centric.</p>

<p><strong>Ruby has blocks, Python does not.</strong></p>

<p><strong>Python has functions, Ruby does not.</strong> In Python you can pass a function or method and pass it to another function, whereas in Ruby, everything is a method and you need to wrap them in Procs to pass them.</p>

<p><strong>Scope/Closures</strong>. In Ruby, closures are defined using blocks &ndash; within a block you have full read and write access to variables defined outside the block. In Python, you can define functions inside of other functions but you don&rsquo;t have write access to variables from the outer function, only read access.</p>

<p><strong>Python uses list comprehensions, which are pretty awesome.</strong> If you want to do an operation with a list, it&rsquo;s often easier in Python. For example, maybe you wanted to return a new list of all the square numbers of elements greater than 10, you could do this in Python:
```python
my_list = [1, 5, 9, 11, 12, 13]</p>

<p>[x**2 for x in my_list if x > 10]</p>

<h1>=> [121, 144, 169]</h1>

<p><code>
That's pretty expressive. In Ruby, the following would be a good solution but it's just less easy to read:
</code>ruby
my_list = [1, 5, 9, 11, 12, 13]</p>

<p>my_list.select { |item| item > 10 }.collect { |value| value ** 2 }</p>

<h1>=> [121, 144, 169]</h1>

<p>```
Obviously both work and return the same value &ndash; but Python does it in one pass instead of having to hold 3 arrays in memory.</p>

<p><strong>Python has tuples, Ruby uses arrays to simulate tuples.</strong> Maybe someday soon I&rsquo;ll appreciate this difference.</p>

<p><strong>Ruby has case statements, Python doesn&rsquo;t.</strong> I don&rsquo;t really care too much about this one.</p>

<p><strong>Ruby has ternary operators, Python doesn&rsquo;t.</strong> require_ternary_operators_to_stay_sane?? Ruby : Python</p>

<p><strong>Python has multiple inheritance, Ruby uses modules and mix-ins.</strong> This is actually pretty important, and I think I prefer the module approach.</p>

<p><strong>Python only has single-line lambda functions.</strong> Ruby has a quasi-equivalent with the block, and so Ruby code becomes more functional as a result &ndash; I tend to gravitate towards the <code>each</code> and <code>map</code> methods in Ruby but definitely go more for the <code>for x in y</code> approach in Python. However, there is a nice equivalent for the <code>map</code> method in Python. Given a Python function, you can also do things functionally instead of with the list comprehension:</p>

<p>```python
def my_method(x):</p>

<pre><code>    return x + 4
</code></pre>

<p>my_list = [1,2,3]</p>

<p>map(my_method, my_list)</p>

<h1>=> [5, 6, 7]</h1>

<p>```</p>

<p><strong>NumPy, SciPy, Scikit-learn</strong>. Python has really cool libraries for data science, which is what I might be interested in down the line.</p>

<h3>Conclusion:</h3>

<p>There&rsquo;s no winner here. They&rsquo;re both incredible languages and I&rsquo;m still a whitebelt in both. However, there&rsquo;s definitely value to learing both &ndash; they both teach slightly different ways of attacking problems, both have great web solutions (I think Rails still has Django beat right now), and both are a distinct pleasure to work with.</p>

<p>Tata for now.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Public and Private Methods in Ruby]]></title>
    <link href="http://wlowry88.github.io/blog/2014/09/08/public/"/>
    <updated>2014-09-08T20:33:02-04:00</updated>
    <id>http://wlowry88.github.io/blog/2014/09/08/public</id>
    <content type="html"><![CDATA[<h3>Method Access Rules</h3>

<p>While the end user of your program is never going to be using the methods you define in a class directly, it is still helpful to control access to your methods. Envision a team situation in which multiple developers use instances of the same class; it is useful to control which methods can be used.</p>

<p>A simple way to think about the difference is to imagine our class is an airplane (I&rsquo;m writing this aboard one, in fact.)</p>

<!-- More -->


<h3>Public Methods</h3>

<p>In our <code>Plane</code> class, we have a few public instance methods. We don&rsquo;t need to specify that a method be public because that is their default.</p>

<p>```ruby
class Plane</p>

<pre><code>attr_reader :type, :fuel, :landed, :people, :personal_info_of_passengers, :burning_fuel

def initialize(model)
    @model = model
    @fuel = 100
    @airborne = false
    @burning_fuel = false
end

def take_off
    puts "Firing up engines"
    puts "Fuel levels are #{fuel}."
    @airborne = true
    fire_up_engine
end

def fire_up_engine
    puts "firing up the engine"
    begin_gas_combustion
end

def begin_gas_combustion
    puts "combustin' the gas!"
    burning_fuel = true
end

def personal_info_of_passengers(people)
    people.map do |person|
        person.social_security_number
    end
end
</code></pre>

<p>end
```
Woah, wait a second. It&rsquo;s all well and good that we&rsquo;re able to see what type of plane we&rsquo;re working with, the fuel levels, and even whether or not we&rsquo;re airborne. However, there are a few things that we definitely don&rsquo;t want to be usable outside our class.</p>

<p>An object is easy to think about as something that does tasks for you, and its methods are the actions of doing those things. Public methods are like the API &ndash; where calls are made to the instances of the object. Private methods, on the other hand, are tasks that you might not want to be used freely. For example, the method <code>begin_gas_combustion</code> is a component of the method <code>fire_up_engine</code> but it&rsquo;s unclear whether or not you&rsquo;d want to use it in any other context. In fact, it would probably be unsafe to be able to use it in other contexts. Luckily, Ruby enables use of private methods to get around this problem.</p>

<h3>Private Methods</h3>

<p><strong>A private method cannot be called with an explicit receiver.</strong> This means that if we specify <code>begin_gas_combustion</code> to be a private method, we shouldn&rsquo;t be able to call <code>begin_gas_combustion</code> on instances of our <code>Plane</code> class explicitly. Let&rsquo;s rewrite a bit of our Plane class:</p>

<p>```ruby
class Plane</p>

<p>&hellip;</p>

<pre><code>def fire_up_engine
    puts "firing up the engine"
    begin_gas_combustion
end

private

    def begin_gas_combustion
        "combustin' da gas!"
        burning_fuel = true
    end
</code></pre>

<p>end
<code>
Ok, that seems to make a bit more sense. Let's test out our methods.
If you try, you'll get the following:
</code>ruby</p>

<p>wills_plane = Plane.new(747)
wills_plane.begin_gas_combustion</p>

<h1>=> &lsquo;<main>&rsquo;: private method &lsquo;begin_gas_combustion&rsquo; called for #&lt;Plane:0x00000002aeae50> (NoMethodError)`</h1>

<p><code>``
This makes sense based on our definition of private methods - the instance</code>will` is now the explicit receiver of the method as called. However, when we try the following:</p>

<p>```ruby</p>

<p>wills_plane.fire_up_engine</p>

<h1>=> &ldquo;firing up the engine&rdquo;</h1>

<h1>=> &ldquo;combustin' da gas!&rdquo;</h1>

<p>```
Here, since the method gets called within a public method, there is an implicit receiver &ndash; the specific instance of the object &ndash; and we are ok.</p>

<h3>Private Setter (=) Methods</h3>

<p>Private methods with the &ldquo;no explicit receiver&rdquo; rule do hit problems, however, with writer / setter methods. In these methods, you can&rsquo;t use the implicit receiver because Ruby would assume you were using a local variable instead of a method without the keyword <code>self</code>. Therefore, there is an exception &ndash; Ruby doesn&rsquo;t apply the rule to setter methods as long as the explicit receiver is <code>self</code>.</p>

<h3>You Can Bypass Private Methods with &lsquo;send&rsquo;</h3>

<p>Ruby has given us a way to get around our rule, however. You can always just use the <code>send</code> method to send any method to any object.</p>

<p>Hopefully this clears up the value / usage of private methods, and see you next time.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linked Lists in Ruby]]></title>
    <link href="http://wlowry88.github.io/blog/2014/08/20/linked-lists-in-ruby/"/>
    <updated>2014-08-20T23:51:07-04:00</updated>
    <id>http://wlowry88.github.io/blog/2014/08/20/linked-lists-in-ruby</id>
    <content type="html"><![CDATA[<p>This post is centered around linked lists using Ruby.</p>

<p>A linked list is a <strong>data structure</strong> that consists of a collection of nodes that represent a sequence. Each element in a linked list will contain a datum and a reference to the next element in the linked list (a pointer).</p>

<p>In Ruby it makes most sense to use arrays due to built-in methods such as <code>shift</code>, <code>unshift</code>, <code>enq</code>, <code>deq</code>, <code>push</code> and <code>pop</code>, but it is helpful to know why linked lists can be beneficial.</p>

<!-- More -->


<p>Linked lists' biggest advantage over arrays in other languages is their ability to insert / remove list elements without reallocating or reorganization of the entire data structure. Arrays have indices, so deleting a value at index 0 for example requires every single item to be reindexed.</p>

<p>The flip-side of this, however, is that performing operations requiring access to particular elements of a linked list can be cumbersome. For example, finding the last element of a linked list requires scanning every element of the list.</p>

<p>Here are some additional advantages and disadvantages of linked lists:</p>

<p>LL Pros:</p>

<ul>
<li><p>Dynamic &ndash; LL&rsquo;s allocate the needed memory when the program is initiated and can can expand in real time without memory overload.</p></li>
<li><p>Insertion and deletion is easy.</p></li>
<li><p>It&rsquo;s easy to building linear data structures such as stacks and queues with linked lists.</p></li>
</ul>


<p>LL Cons:</p>

<ul>
<li><p>Since each element holds a value and a pointer, it&rsquo;s more memory intensive.</p></li>
<li><p>You have to access nodes sequentially since that&rsquo;s how they&rsquo;re defined; furthermore they&rsquo;re not stored continuously so it takes longer to access an element.</p></li>
<li><p>With a singly-linked list it&rsquo;s pretty much terrible to reverse traverse. Doubly-linked lists contain a pointer to the previous node as well but that&rsquo;s even more memory intensive.</p></li>
</ul>


<h3>Ruby Implementation</h3>

<p>It makes sense to define two ruby classes in implementing a linked list in Ruby &ndash; one for each element, called <code>Node</code>, and the other for the list itself, called <code>LinkedList</code>.</p>

<p>Here is the first. Note that a Node is initialized with its own data point as well as a pointer to the next Node.</p>

<p>```ruby
class Node</p>

<pre><code>attr_accessor :val, :next

def initialize(val, next_node)
    @val = val
    @next = next_node
end
</code></pre>

<p>end
```
Next, the LinkedList class:</p>

<p>```ruby
class LinkedList</p>

<p>  def initialize(val)</p>

<pre><code>@head = Node.new(val, nil)
</code></pre>

<p>  end</p>

<p>  def add(val)</p>

<pre><code>current = @head
while current.next != nil
  current = current.next
end
current.next = Node.new(val, nil)
</code></pre>

<p>  end</p>

<p>  def delete(val)</p>

<pre><code>current.next = @head
if current.val = val
  @head = current.next
else
  while (current.next != nil) &amp;&amp; (current.next.val != val)
    current = current.next
  end
  unless current.next == nil
    current.next = current.next.next
  end
end
</code></pre>

<p>  end</p>

<p>  def return_list</p>

<pre><code>elements = []
current = @head
while current.next != nil
  elements &lt;&lt; current
  current = current.next
end
elements &lt;&lt; current
</code></pre>

<p>  end
end</p>

<p>```</p>

<p>And there you have it &ndash; a basic implementation of a singly linked list in Ruby. Next time we&rsquo;ll use a linked list to build a stack and a queue.</p>
]]></content>
  </entry>
  
</feed>
